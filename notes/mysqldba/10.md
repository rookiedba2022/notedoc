## 1. 主从复制架构演变

### 1.1 传统复制

- 基础架构(仅用MySQL本身就能实现，不需要第三方软件的配合)
  - 一主一从
  - **一主多从**
  - 双主结构（互为主从）
  - **多级主从**

#### 只有主从复制是不够的

假如你构建了一个一主多从，你的应用只在master库进行读写，有一天master库突然挂了，应该怎么办？

很明显，是将应用连接到从库上去，但是这件事怎么去做呢？人为去做？还是自动转移？

一个常见的思路用keepalive做vip地址漂移，但是，主库从库之间并不是100%同步的，keepalive实现vip地址漂移只能保证实现切换到从库(Fail Over)，但是并不能保证切换到的从库数据一定与原来的主库是同步的，这并不是高可用。

高可用，不仅要保证**故障转移**，而且要保证从库、主库的**数据一致**。常见的高可用软件，有MHA、PXC、MGR等等。

但是MHA也是有自己的缺陷的，MHA无法实现读写分离，需要与其他的中间件一起配合使用，将读的压力分散到从库上。

以上所述的架构（一主多从+读写分离+keepalive+MHA）算是一定意义上的高可用，但它也有明显的缺陷：写的压力过大。

#### 架构演变

### 1.2 高级架构

- 高可用
  - MHA
    - facebook
    - RDS MySQL (TMHA)
      - 两节点
    - Oracle官方的operator (K8S + MHA)
      - 实现自愈
  - PXC
  - MGC
  - MySQL Cluster
  - InnoDB Cluster
    - MySQL 8.0 普及后未来可期
- 读写分离
  - Atlas
  - ProxySQL
  - Maxscale
  - Mycat
- 分布式架构
  - Mycat
  - DBLE
  - sharding-JDBC

## 2. MHA高可用搭建

### 2.1 准备环境

一主二从GTID + 一监控



