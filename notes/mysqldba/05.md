## 1. 索引

### 1.1 索引简介

- 相当于书中的目录，帮助存储引擎快速找到数据的一个数据结构
- 条件类查询
  - where
  - group by
  - order by
  - join on
  - distinct

### 1.2 索引类型

- 类型
  - Btree (Blance Tree)
    - InnoDB，MyISAM
  - 哈希索引
    - Memory
    - InnoDB也会维护自己的AHI的hash索引
  - FULLTEXT
    - 全文索引
    - 一般在大字段使用，用ES数据库存储大字段
  - GIS
    - 地理位置索引
    - 一般MangoDB可以替代



### 1.3 MySQL为什么要用BTree(B+ Tree)算法

- 相比其他的数据结构（二叉树、红黑树......），BTree是**平衡**的
  - 不管找任何一个值，都要找3次

- MySQL中的BTree，至少有一个根和页，枝是否有要看数据量

### 1.4 MySQL怎么使用BTree结构的

- 聚簇索引
- 辅助索引

#### 回顾段区页

- 段
  - 一个表就是一个段，由多个区构成
- 区
  - 又称为簇，由连续的64个页组成，默认1M
- 页
  - 一个数据页16kb，是MySQL IO的最小单元

### 1.5 聚簇索引（InnoDB）

- 严格来说，聚簇索引并不是一种单独的索引类型，而是一种数据组织方式
- 聚簇索引的本质是在同一个结构里保留了B-Tree索引和数据行
- 一个表只能有一个聚簇索引

#### 生成条件

- 创建表时，如果设置了主键ID列prim key，自动把ID列作为聚簇索引列
- 没有主键，会选择第一个唯一键(UK)作为聚簇索引列
- 如果都没有，生成隐藏列(ROWID)，作为聚簇索引列作用

#### 作用

- 在存储数据的时候，InnoDB会申请连续的磁盘空间进行存储（即区）
- 数据存储时，按照聚簇索引值的顺序在磁盘有序存储
  - 实现了逻辑和物理上都是有序的
- 以上又被称为聚簇索引组织存储数据表，简称索引组织表，数据存储即按照索引组织表的顺序在磁盘上存储

#### 聚簇索引的B树构建



- 叶子结点
  - 由于逻辑上有序的数据按照聚簇索引的组织表有序存储在磁盘上，因此数据本身就是叶子结点
- 枝节点
  - 存指针
  - 存范围



- 等值查询的过程
- 范围查询的过程

根节点到枝节点到叶子节点的，并不一定是顺序IO

B+ Tree

#### 优点与缺点

- 优点
  - 把相关的数据保存到一起
  - 由于索引和数据存在同一个结构中，数据访问更快
- 缺点
  - 对于内存全部存在数据里的应用，访问顺序并不重要
  - 插入速度严重依赖于插入顺序
  - 更新聚簇索引列的代价很高，innodb会强制将每个被更新的行移动到新的位置
  -

### 1.6 辅助索引

- DBA需要维护管理的最常见的索引，聚簇索引只要建立了主键，系统就可以自动生成
- 主要作用
  - 优化非聚簇索引列的条件查询

构建过程原理

- 构建在普通查询的条件列上

### 1.7 影响索引树高度的因素

聚簇索引一般建议2~3层为佳，3层可以存2000w+数据

辅助索引3层为佳

影响因素

- 数据行
  - 解决
    - 分区表（逻辑）：能解决索引的问题，但不能解决业务压力的问题
    - 分库分表（物理）
    - 历史数据归档
      - `pt-archive`
- 数据类型的选择
- 索引列值的长度
  - 对于太长的使用前缀索引

### 1.8 索引的管理操作

- 生产的繁忙期间，不要做创建索引和删除索引的操作
- 大表创建索引会比较慢，不要在生产时做

#### 创建

- 原则
  - 将经常作为查询条件的列作为索引列

1. 单列索引 `alter table <table_name> add index <index_name> (<column_name>)`



2. 联合索引



3. 前缀索引（字符串列）



#### 查看

- `desc` 看key列

| KEY  | 含义     |
| ---- | -------- |
| PRI  | 聚簇索引 |
| MUL  | 辅助索引 |
| UNI  | 唯一索引 |

- `show index from <> \G `

#### 删除索引

`alter table <table_name> drop <indexname>`


## 2. 执行计划分析

### 2.1 执行计划介绍



查看执行计划

```mysql
mysql> explain select Name, CountryCode from city where ID=11;
```

![image-20220129111437594](C:\Users\andy\AppData\Roaming\Typora\typora-user-images\image-20220129111437594.png)



需要关注的列

| 列名            | 意思           | 作用 |
| --------------- | -------------- | ---- |
| `table`         | 针对的表       |      |
| `type`          |                |      |
| `possible_keys` |                |      |
| `key`           |                |      |
| `key_len`       | 索引列值得长度 |      |
| `rows`          |                |      |
| `Extra`         |                |      |

#### Type

| Type输出      | 意思                                     | 后果                | 原因/情况                          |
| ------------- | ---------------------------------------- | ------------------- | ---------------------------------- |
| ALL           | 全表扫描，不走任何索引                   | CPU I/O负担大幅增加 | 1. 没有索引；2. 有索引但是没有走   |
| index         | 全索引扫描，需要遍历整个索引             |                     |                                    |
| range         | 索引范围扫描                             |                     | `>` `<` `>=` `<=` `like` `in` `or` |
| ref           | 辅助索引等值查询                         |                     |                                    |
| eq_ref        | 多表连接中，非驱动的关联条件是主键或唯一 |                     |                                    |
| const(system) | 主键或唯一键等值查询                     |                     |                                    |
| NULL          | 查不到数据                               |                     | 索引里没有值                       |

ALL演示

index演示

range演示

- 通常来说，`in` `or`的性能要比前面几个的低得多，可以用子查询改写
  - 但是，需要考虑到重复值多少的问题，因为改写过后，实际上对数据页读了两遍，假如重复值（？）多的话，其实没必要改些

ref演示

eq_ref演示



- 至少range以上的级别

#### possible_keys, key

#### key_len

- 作用
  - 单列索引比较长，需要评估是否需要前缀索引
  - 如果是联合索引，帮助判断应用了几部分
- 计算
  - 索引列的定义的最大预留长度
  - 与数据类型、是否非空、字符集有关
    - utf8可以存储3个字节长度，utf8mb4可以存储4个字节

| 数据类型(整数) | 是否非空 | key_len |
| -------------- | -------- | ------- |
| int            | not null | 4       |
| tinyint        | not null | 1       |
| int            |          | 4+1     |
| tinyint        |          | 1+1     |

| 数据类型(字符串) | 是否非空 | key_len  |
| ---------------- | -------- | -------- |
| char(10)         | not null | 10*4     |
| varchar(10)      | not null | 10*4+2   |
| char(10)         |          | 10*4+1   |
| varchar(10)      |          | 10*4+2+1 |

```mysql
mysql> create table t1 (
    -> n1 int not null,
    -> n2 int,
    -> c1 char(10) not null,
    -> c2 varchar(24)
    -> )charset=utf8mb4;
Query OK, 0 rows affected (0.01 sec)

mysql> alter table t1 add index idx(n1,n2,c1,c2);
```

`select * from t1 where n1=10 and n2=20 and c1='a' and c2='b';`的Key_len

#### 联合索引的应用细节

索引：`idx(a,b,c,d)`

- 全部覆盖
  - ``

- 最左原则
  - 查询中，应用到索引时，至少要有最左列
  - 最左列是第一过滤条件，一般选择重复值少的列作为最左列

#### extra

## 3. 索引应用规范

### 3.1 索引建立的原则

- 建表时一定要有主键
  - 一般是一个无关的自增数字列

- 选择唯一性索引
  - 唯一性是很难保证的，在实际中尽量把重复值少的作为联合索引的最左侧
  - 必须要使用重复值较多的列作为查询条件（例如：男女），可以将表逻辑拆分
  - 计算列中重复值比例的方法

```mysql
mysql> select count(*) from world.city;
+----------+
| count(*) |
+----------+
|     4079 |
+----------+
1 row in set (0.00 sec)

mysql> select count(distinct countrycode) from world.city;
+-----------------------------+
| count(distinct countrycode) |
+-----------------------------+
|                         232 |
+-----------------------------+
1 row in set (0.00 sec)
```

- 尽量使用前缀来索引
  - 尽量保证索引的选择性(不重复的索引值与数据表记录总数的比例)
  - 诀窍是决定前缀的合适长度（高性能MySQL第三版154页）

- 建立正确顺序的多列索引，避免建立单列索引
  - 选择匹配度高的作为第一列

- 限制索引的条目
  - 每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大
  - 修改表时，对索引的重构和更新会很麻烦
  - 索引多，优化器的负担重
  - 可以使用工具分析索引是否有用

- 删除不再使用或很少使用的索引

- 大表加索引时，要在业务不繁忙的期间操作

- 尽量少在经常更新值的列上建立索引

### 3.2 不走索引的情况

- 没有查询条件，或者查询条件没有建立索引
- 查询结果集是原表中的大部分数据（15~25%以上），优化器觉得没必要走索引了
  - 看rows
  - 如何解决？
    - limit <估计的行数>
- 索引本身失效，统计信息不真实
  - MySQL中就有对索引的统计信息：`mysql.innodb_index_stats`、`mysql.innodb_table-stats`，但是这两个表不是实时更新的，而索引的应用依赖于这些信息，如果这些统计信息过旧，优化器会认为索引失效了
  - 表内容频繁更新，有可能出现索引失效
- 查询条件使用函数在索引列上，或者对索引列进行了运算



```mysql
mysql> mysql> desc select * from world.city where id-1=10;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | city  | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 4046 |   100.00 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

```
